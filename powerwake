#!/usr/bin/python
#
#    powerwake - a smart remote host waking utility, supporting multiple
#                waking methods, and caching known hostnames and addresses
#
#    Copyright (C) 2009 Canonical Ltd.
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import commands
import os
import re
import socket
import struct
import sys

DEBUG = 0

# Generic debug function
def debug(level, msg):
    if DEBUG >= level:
        print("%s" % msg)

# Generic error function
def error(msg):
    debug(0, "ERROR: %s" % msg)
    sys.exit(1)

def wakeonlan(mac):
    nonhex = re.compile('[^0-9a-fA-F]')
    mac = nonhex.sub('', mac)
    if len(mac) != 12:
        error("Malformed mac address [%s]" % mac)
    debug(0, "Sending magic packet to [%s]" % mac)
    # We should cache this to /var/cache/powerwake,
    # in case arp entry isn't available next time
    data = ''.join(['FFFFFFFFFFFF', mac * 20])
    send_data = ''
    for i in range(0, len(data), 2):
        send_data = ''.join([send_data,
                             struct.pack('B', int(data[i: i + 2], 16))])
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.sendto(send_data, ('<broadcast>', 7))

def arp(target="localhost", update_arp=0):
    to_mac = {}
    # Load hostnames
    for i in os.popen("/usr/sbin/arp | awk '{print $1 \" \"  $3}'"):
        (h, m) = i.split()
        to_mac[h] = m
    # Load ip addresses
    for i in os.popen("/usr/sbin/arp -n | awk '{print $1 \" \"  $3}'"):
        (h, m) = i.split()
        to_mac[h] = m
    # If the target isn't found, ping, and try again
    if update_arp == 0 and not to_mac.has_key(target):
        commands.getoutput("ping -c 1 %s" % target)
        return arp(target, 1)
    else:
        return to_mac

if __name__ == '__main__':
    # Process command line parameters
    for i in sys.argv[1:]:
        # If parameter matches a system with a static configuration, use it!
        # ^^^ Not yet implemented, default to wake-on-lan method for now
        method = "--wol"
        if method == "--wol":
            nonhex = re.compile('[^0-9a-fA-F]')
            mac = nonhex.sub('', i)
            if len(mac) == 12:
                pass
            else:
                to_mac = arp(i, 0)
                if to_mac.has_key(i):
                    debug(0, "Trying to wake host [%s]" % i)
                    mac = to_mac[i]
                else:
                    error("Could not determine the MAC address of [%s]" % i)
            wakeonlan(mac)
