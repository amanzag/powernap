#!/usr/bin/python
#
#    powerwake - a smart remote host waking utility, supporting multiple
#                waking methods, and caching known hostnames and addresses
#
#    Copyright (C) 2009 Canonical Ltd.
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import commands
import os
import re
import socket
import struct
import sys

global DEBUG, PKG
DEBUG = 0
PKG = "powerwake"

# Generic debug function
def debug(level, msg):
    if DEBUG >= level:
        print("%s" % msg)

# Generic error function
def error(msg):
    debug(0, "ERROR: %s" % msg)
    sys.exit(1)

def wakeonlan(mac):
    nonhex = re.compile('[^0-9a-fA-F]')
    mac = nonhex.sub('', mac)
    if len(mac) != 12:
        error("Malformed mac address [%s]" % mac)
    debug(0, "Sending magic packet to [%s]" % mac)
    # We should cache this to /var/cache/powerwake/ethers,
    # in case arp entry isn't available next time
    data = ''.join(['FFFFFFFFFFFF', mac * 20])
    send_data = ''
    for i in range(0, len(data), 2):
        send_data = ''.join([send_data, struct.pack('B', int(data[i: i + 2], 16))])
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
    sock.sendto(send_data, ('<broadcast>', 7))

def is_mac(mac):
    r1 = re.compile('^[0-9a-fA-F]{12}$')
    r2 = re.compile('^[0-9a-fA-F]{2}.[0-9a-fA-F]{2}.[0-9a-fA-F]{2}.[0-9a-fA-F]{2}.[0-9a-fA-F]{2}.[0-9a-fA-F]{2}$')
    if r1.match(mac) or r2.match(mac):
        return 1
    else:
        return 0

# Source the cached, known arp entries
def get_arp_cache():
    host_to_mac = {}
    f = open("/var/cache/%s/ethers" % PKG, 'r')
    for i in f.readlines():
        try:
            (m, h) = i.split()
            host_to_mac[h] = m
        except:
            pass
    f.close()
    return host_to_mac

# Source the current, working arp table
def get_arp_current(host_to_mac):
    # Load hostnames
    for i in os.popen("/usr/sbin/arp | awk '{print $3 \" \"  $1}'"):
        (m, h) = i.split()
        host_to_mac[h] = m
    # Load ip addresses
    for i in os.popen("/usr/sbin/arp -n | awk '{print $3 \" \"  $1}'"):
        (m, h) = i.split()
        host_to_mac[h] = m
    return host_to_mac

def write_arp_cache(host_to_mac):
    f = open("/var/cache/%s/ethers" % PKG, 'w')
    for h in host_to_mac:
        if is_mac(host_to_mac[h]):
            f.write("%s %s\n" % (host_to_mac[h], h))
    f.close()

def get_arp_hash():
    host_to_mac = get_arp_cache()
    host_to_mac = get_arp_current(host_to_mac, "localhost", 0)
    write_arp_cache(host_to_mac)
    return host_to_mac

if __name__ == '__main__':
    # Seed the mac cache
    host_to_mac = get_arp_hash()
    # Process command line parameters
    for i in sys.argv[1:]:
        # If parameter matches a system with a static configuration, use it!
        # ^^^ Not yet implemented, default to wake-on-lan method for now
        method = "--wol"
        if method == "--wol":
            if is_mac(i):
                # this appears to be a mac address, just use it
                pass
            else:
                if host_to_mac.has_key(i):
                    # mac found in the hash
                    debug(0, "Trying to wake host [%s]" % i)
                    m = host_to_mac[i]
                else:
                    # cannot autodetect the mac address
                    error("Could not determine the MAC address of [%s]" % i)
            wakeonlan(m)
