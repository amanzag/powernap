#!/usr/bin/python
#
#    powernapd - monitor a system process table; if IDLE amount of time
#               goes by with no MONITORED_PROCESSES running, run ACTION
#    Copyright (C) 2009 Canonical Ltd.
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#             Adam Sutton <dev@adamsutton.me.uk>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# #########################################################################
# Imports
# #########################################################################

import commands
import logging, logging.handlers
import os
import re
import signal
import sys
import time
import threading

# #########################################################################
# Configuration
# #########################################################################

PKG      = 'powernap'
CONFIG   = {
  'log'               : '/var/log/%s.log' % PKG,
  'pid'               : '/var/run/%s.pid' % PKG,
  'interval'          : 1.0,
  'absent'            : sys.maxint,
  'grace'             : 60.0,
  'debug'             : 0,
  'daemon'            : True,
  'action'            : '/usr/sbin/powernap',
  'monitors'          : [],
  'plugin_dir'        : './plugins',
}
RUNNING  = True
MONITORS = []

# Config signal handler
def sig_handler_config ( sig, frame ):
    if ( sig == signal.SIGHUP ):
        debug(logging.DEBUG, 'TODO: do we need config reload support?')

# Load configuration
def load_config ():
    global PKG, CONFIG
    from optparse import OptionParser
    from ConfigParser import ConfigParser

    # Build options
    optp = OptionParser()
    optp.add_option("-c", "--config", dest="config",
                    default=None,
                    help="Specify an alternative configuration file")
    optp.add_option("-l", "--log", dest="log",
                    default=None,
                    help="Specify an alternative log file")
    optp.add_option("--pid", dest="pid",
                    default=None,
                    help="Specify an alternative PID file")
    optp.add_option("-i", "--interval", dest="interval",
                    default=None, type='float',
                    help="Specify interval period in seconds")
    optp.add_option("-a", "--absent", dest="absent",
                    default=None, type='float',
                    help="Specify global absent period in seconds")
    optp.add_option("-g", "--grace", dest="grace",
                    default=None, type='float',
                    help="Specify global grace period in seconds")
    optp.add_option("-d", "--debug", dest="debug",
                    default=None, type='int',
                    help="Specify level of debug logging")
    optp.add_option("--nodaemon", dest="daemon",
                    default=None,
                    action='store_false',
                    help="Do not run as a daemon process")
    optp.add_option('--monitor', dest='monitors',
                    default=[], action='append',
                    help='Specify monitor class to load')

    # Parse command line
    (opts,args) = optp.parse_args()

    # Get config file path
    conf_path   = '/etc/%s/config' % PKG
    if ( opts.config ): conf_path = opts.config

    # Load config file
    cfgp = ConfigParser()
    if ( os.path.isfile(conf_path) ): cfgp.read([conf_path])

    # Update from config file
    if cfgp.has_section('global'):
      for k, v in cfgp.items('global'):
        CONFIG[k] = eval(v)
        # TODO: how safe is this?

    # Update from command line
    if opts.log       != None: CONFIG['log']       = opts.log
    if opts.pid       != None: CONFIG['pid']       = opts.pid
    if opts.debug     != None: CONFIG['debug']     = opts.debug
    if opts.interval  != None: CONFIG['interval']  = opts.interval
    if opts.absent    != None: CONFIG['absent']    = opts.absent
    if opts.grace     != None: CONFIG['grace']     = opts.grace
    if opts.daemon    != None: CONFIG['daemon']    = opts.daemon
    if opts.monitors:          CONFIG['monitors']  = opts.monitors

# ###########################################################################
# Logging
# ###########################################################################

# Generic debug function
def debug(level, msg):
    import datetime
    global CONFIG
    if level >= (logging.ERROR - 10*CONFIG['debug']):
        if not CONFIG['daemon']:
            print '%s: %s' % (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'), msg)
        logging.log(level, msg)

# Generic error function
def error(msg):
    debug(logging.ERROR, msg)
    sys.exit(1)

# ###########################################################################
# Daemon Setup
# ###########################################################################

# "Forking a Daemon Process on Unix" from The Python Cookbook
def daemonize (stdin="/dev/null", stdout="/var/log/%s.log" % PKG, stderr="/var/log/%s.err" % PKG):

    # First fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #1 failed: (%d) %sn" % (e.errno, e.strerror))
        sys.exit(1)

    # Setup environment
    os.chdir("/")
    os.setsid()

    # Second fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #2 failed: (%d) %sn" % (e.errno, e.strerror))
        sys.exit(1)

    # File handles
    for f in sys.stdout, sys.stderr: f.flush()
    si = file(stdin, 'r')
    so = file(stdout, 'a+')
    se = file(stderr, 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

# Create PID file (locked)
def create_pid ():
    global CONFIG
    import fcntl
    f = None
    try:
        f = open(CONFIG['pid'], 'w')
    except:
        error("Administrative privileges are required to run %s" % PKG);
   
    try:
        fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
        f.write(str(os.getpid()))
    except:
        error("Another instance is running [%s]" % f.read())

# Setup signal handlers
def setup_signal_handlers ():
    signal.signal(signal.SIGHUP,  sig_handler_config)
    signal.signal(signal.SIGINT,  sig_handler_exit)
    signal.signal(signal.SIGQUIT, sig_handler_exit)
    signal.signal(signal.SIGTERM, sig_handler_exit)
    signal.signal(signal.SIGUSR1, sig_handler_take_action)

# Clean up lock file on termination signals
def sig_handler_exit ( sig, frame ):
    # Force shutdown!
    if ( sig == signal.SIGTERM ):
      debug(logging.INFO, "Forcing shutdown")
      sys.exit(1)
    else:
      global RUNNING
      debug(logging.INFO, "Requesting shutdown")
      RUNNING = False

# ###########################################################################
# Action Handling / Alerts
# ###########################################################################

# Send a message to system users, that we're about to take an action,
# and sleep for a grace period
def alert_user_warning ():
    global CONFIG
    msg1 = "PowerNap will take the following action in [%s] seconds: [%s]" % (CONFIG['grace'], CONFIG['action'])
    msg2 = "To cancel this operation, press any key in any terminal"
    debug(logging.WARNING, msg1)
    commands.getoutput("echo '%s\n%s' | wall" % (msg1, msg2))

# Inform the user suspend has been cancelled
def alert_user_cancelled ():
    global CONFIG
    msg = "PowerNap detected activity. Canceling action [%s]" % CONFIG['action']
    debug(logging.WARNING, msg)
    commands.getoutput("echo '%s' | wall" % msg)

# TODO: notify authorities about action taken
def notify_authorities():
    global CONFIG
    debug(logging.WARNING, "Taking action [%s]" % CONFIG['action'])

# Zero the counters and take the action
def take_action():
    global CONFIG
    notify_authorities()
    os.system(CONFIG['action'])

# Handler for asynchronous external signals
def sig_handler_take_action ( sig, frame ):
    if ( sig == signal.SIGUSR1 ): take_action()

# ###########################################################################
# Monitors
#   monitors are the key element in this system, they monitor particular
#   aspects of the system to determine if activity is present that should
#   stop the machine from going into suspend
#
#   The implementation is not as python like as it could be, its assumed
#   that all Monitor extend from the Monitor class which provides the basic
#   "stubbed" interface
#
#   Most monitors don't run seperate threads, however some do and therefore
#   the start/stop methods are added (could also be used to reset counts
#   etc...)
# ###########################################################################

# Generate monitors
#   TODO: this load system is crap, files must be ordered to work
#         but its just to prove basic concept
def create_monitors ( monitor_config ):
    ret = []

    # Source all plugins
    for f in os.listdir(CONFIG['plugin_dir']):
        p = os.path.join(CONFIG['plugin_dir'], f)
        if os.path.isfile(p):
            try:
                execfile(p, globals())
            except Exception, e:
                print 'ERROR: eval %s [e=%s]' % (p, str(e))

    # Process each
    for m in monitor_config:
        pts     = m.split('=', 2)
        monitor = globals()[pts[0]](eval(pts[1]))
        ret.append(monitor)

    return ret

# Generic monitor (doesn't really do much)
#   Note: as this is python there it's not required that anything extend from
#         this. It's merely here for conveinience and to serve as a guide as
#         to the required API that should be provided by Monitor objects
class Monitor ( object ):
    def __init__ ( self, config ):
        if not config.has_key('name'): config['name'] = 'unknown'
        self.name = config['name']
        debug(logging.DEBUG, "Creating monitor %s" % self.name)
    def __repr__ ( self ):
        return self.name

    # Reset monitor
    def reset ( self ): pass

    # Start the monitor
    def start ( self ): pass

    # Stop the monitor
    def stop  ( self ): pass

    # Check if monitored resource is active
    def active ( self ): return False


# Find list of PIDs that match a given regex (cmdline)
#   Note: I prefer using the /proc filesystem to ps output, less parsing is required!
def find_pids ( regex ):
    ret = []
  
    for d in os.listdir('/proc'):
        try:
            path = '/proc/%s/cmdline' % d
            if os.path.isfile(path):
                fp      = open(path)
                cmdline = fp.read()
                fp.close()
                if regex.search(cmdline):
                    ret.append(int(d))
        except: pass

    return ret

# ###########################################################################
# Main 
# ###########################################################################

# Search process table, increment counters, take actions, sleep
def powernapd_loop():
    global RUNNING, CONFIG
    last_a = time.time()
    warned = False

    # Until told to stop
    while RUNNING:

        # Sleep (get accurate period?)
        debug(logging.DEBUG, "Sleeping [%d] seconds" % CONFIG['interval'])
        time.sleep(CONFIG['interval'])

        # Check for each monitor
        active = 0
        for m in MONITORS:
            if m.active():
                debug(logging.DEBUG, '  %-30s is active' % m)
                active += 1
            else:
                debug(logging.DEBUG, '  %-30s is inactive' % m)

        # Something is active
        if ( active > 0 ):
            debug(logging.DEBUG, "Active monitors detected [count = %d]" % active)
            last_a = time.time()

            # Inform sysem users suspend terminated
            if warned:
                alert_user_cancelled()
                warned = False
          
        # Absent
        else:
            now    = time.time()
            absent = now - last_a
            debug(logging.DEBUG, "No active monitors detected [absent = %d/%d]" % (absent, CONFIG['absent']))

            # Time is up (powerdown)
            if ( absent >= CONFIG['absent'] ):
                take_action()

                # Wakeup (reset)
                warned = False
                last_a = time.time()
                for m in MONITORS: m.reset()

                # Log sleep period
                asleep = last_a - now
                days   = int(asleep / 86400)
                asleep = asleep % 86400
                hrs    = int(asleep / 3600)
                asleep = asleep % 3600
                mins   = int(asleep / 60)
                secs   = asleep % 60
                debug(logging.INFO, "System resumed after being asleep for %02d days %02d hrs %02d min %02d sec"
                      % (days, hrs, mins, secs))

            # Grace period
            elif ( (CONFIG['absent'] - absent) <= CONFIG['grace'] ):
                if ( not warned ):
                    alert_user_warning()
                    warned = True

# Main program
if __name__ == '__main__':

    # Configure everything
    load_config()
    logging.basicConfig(filename=CONFIG['log'], level=logging.NOTSET,
                        format='%(asctime)s %(levelname)-8s %(message)s',
                        datefmt='%Y-%m-%d_%H:%M:%S')
    MONITORS = create_monitors(CONFIG['monitors'])

    # Process setup
    create_pid()
    setup_signal_handlers()
    if CONFIG['daemon']: daemonize()

    # Debug
    debug(logging.INFO, "Starting monitors: %s" % MONITORS)

    # Start
    try:
        for m in MONITORS: m.start()

        # Enter the main loop
        powernapd_loop()

    # Oh dear!
    except Exception, e:
        debug(logging.ERROR, "Unexpected exception [e=%s]" % e)

    # Shut it all down
    finally:
        RUNNING = False
        for m in MONITORS: m.stop()
        debug(logging.INFO, "Powernap Daemon terminating")
        sys.exit(0)
