#!/usr/bin/python
#
#    powernapd - monitor a system process table; if IDLE amount of time
#               goes by with no MONITORED_PROCESSES running, run ACTION
#    Copyright (C) 2009 Canonical Ltd.
#
#    Authors: Dustin Kirkland <kirkland@canonical.com>
#             Adam Sutton <dev@adamsutton.me.uk>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, version 3 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

# #########################################################################
# Imports
# #########################################################################

import commands
import logging, logging.handlers
import os
import re
import signal
import sys
import time
import threading

# #########################################################################
# Configuration
# #########################################################################

PKG      = 'powernap'
CONFIG   = {
  'log'               : '/var/log/%s.log' % PKG,
  'lock'              : '/var/run/%s.pid' % PKG,
  'interval'          : 1.0,
  'absent'            : sys.maxint,
  'grace'             : 60.0,
  'debug'             : 0,
  'daemon'            : True,
  'action'            : '/usr/sbin/powernap',
  'monitor_procs'     : [],
  'monitor_udp_ports' : [ 9 ],
  'monitor_io_procs'  : [],
}
RUNNING  = True
MONITORS = []

# Config signal handler
def sig_handler_config ( sig, frame ):
    if ( sig == signal.SIGHUP ):
        debug(logging.DEBUG, 'TODO: do we need config reload support?')

# Load configuration
def load_config ():
    global PKG, CONFIG
    from optparse import OptionParser
    from ConfigParser import ConfigParser

    # Build options
    optp = OptionParser()
    optp.add_option("-c", "--config", dest="config",
                    default=None,
                    help="Specify an alternative configuration file")
    optp.add_option("-l", "--log", dest="log",
                    default=None,
                    help="Specify an alternative log file")
    optp.add_option("-i", "--interval", dest="interval",
                    default=None, type='float',
                    help="Specify interval period in seconds")
    optp.add_option("-a", "--absent", dest="absent",
                    default=None, type='float',
                    help="Specify global absent period in seconds")
    optp.add_option("-g", "--grace", dest="grace",
                    default=None, type='float',
                    help="Specify global grace period in seconds")
    optp.add_option("-d", "--debug", dest="debug",
                    default=None, type='int',
                    help="Specify level of debug logging")
    optp.add_option("--nodaemon", dest="daemon",
                    default=None,
                    action='store_false',
                    help="Do not run as a daemon process")
    optp.add_option('--udp', dest='udp_ports',
                    default=[], action='append', type='int',
                    help='Specify a UDP port receive wakeup messages on')
    optp.add_option('--proc', dest='procs',
                    default=[], action='append',
                    help='Specify a static process to monitor (regexp)')
    optp.add_option('--ioproc', dest='io_procs',
                    default=[], action='append',
                    help='Specify an IO based process to monitor (regexp)')

    # Parse command line
    (opts,args) = optp.parse_args()

    # Get config file path
    conf_path   = '/etc/%s/config' % PKG
    if ( opts.config ): conf_path = opts.config

    # Load config file
    cfgp = ConfigParser()
    if ( os.path.isfile(conf_path) ): cfgp.read([conf_path])

    # Update from config file
    if cfgp.has_section('global'):
      for k, v in cfgp.items('global'):
        CONFIG[k] = eval(v)
        # TODO: how safe is this?

    # Update from command line
    if opts.log       != None: CONFIG['log']       = opts.log
    if opts.debug     != None: CONFIG['debug']     = opts.debug
    if opts.interval  != None: CONFIG['interval']  = opts.interval
    if opts.absent    != None: CONFIG['absent']    = opts.absent
    if opts.grace     != None: CONFIG['grace']     = opts.grace
    if opts.daemon    != None: CONFIG['daemon']    = opts.daemon
    if opts.procs:             CONFIG['monitor_procs']     = opts.procs
    if opts.udp_ports:         CONFIG['monitor_udp_ports'] = opts.udp_ports
    if opts.io_procs:          CONFIG['monitor_io_procs']  = opts.io_procs

    # Configure monitors
    #   TODO: might be good to make this more flexible
    MONITORS.append(InputMonitor())
    for p in CONFIG['monitor_io_procs']:  MONITORS.append(IOMonitor(p))
    for p in CONFIG['monitor_procs']   :  MONITORS.append(ProcessMonitor(p))
    for p in CONFIG['monitor_udp_ports']: MONITORS.append(RemoteMonitor(p))

# ###########################################################################
# Logging
# ###########################################################################

logging.basicConfig(filename=CONFIG['log'], format='%(asctime)s %(levelname)-8s %(message)s', datefmt='%Y-%m-%d_%H:%M:%S', level=logging.NOTSET,)

# Generic debug function
def debug(level, msg):
    global CONFIG
    if level >= (logging.ERROR - 10*CONFIG['debug']):
        logging.log(level, msg)

# Generic error function
def error(msg):
    debug(logging.ERROR, msg)
    sys.exit(1)

# ###########################################################################
# Daemon Setup
# ###########################################################################

# "Forking a Daemon Process on Unix" from The Python Cookbook
def daemonize (stdin="/dev/null", stdout="/var/log/%s.log" % PKG, stderr="/var/log/%s.err" % PKG):

    # First fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #1 failed: (%d) %sn" % (e.errno, e.strerror))
        sys.exit(1)

    # Setup environment
    os.chdir("/")
    os.setsid()

    # Second fork
    try:
        pid = os.fork()
        if pid > 0:
            sys.exit(0)
    except OSError, e:
        sys.stderr.write("fork #2 failed: (%d) %sn" % (e.errno, e.strerror))
        sys.exit(1)

    # File handles
    for f in sys.stdout, sys.stderr: f.flush()
    si = file(stdin, 'r')
    so = file(stdout, 'a+')
    se = file(stderr, 'a+', 0)
    os.dup2(si.fileno(), sys.stdin.fileno())
    os.dup2(so.fileno(), sys.stdout.fileno())
    os.dup2(se.fileno(), sys.stderr.fileno())

# Create PID file (locked)
def create_pid ():
    global CONFIG
    import fcntl
    f = None
    try:
        f = open(CONFIG['lock'], 'w')
    except:
        error("Administrative privileges are required to run %s" % PKG);
   
    try:
        fcntl.lockf(f, fcntl.LOCK_EX | fcntl.LOCK_NB)
        f.write(str(os.getpid()))
    except:
        error("Another instance is running [%s]" % f.read())

# Setup signal handlers
def setup_signal_handlers ():
    signal.signal(signal.SIGHUP, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGQUIT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGUSR1, take_action_handler)

# Clean up lock file on termination signals
def signal_handler(signal, frame):
    debug(logging.INFO, "Stopping %s" % PKG)
    sys.exit(1)

# ###########################################################################
# Action Handling / Alerts
# ###########################################################################

# Send a message to system users, that we're about to take an action,
# and sleep for a grace period
def alert_warn_users ():
    global CONFIG
    msg1 = "PowerNap will take the following action in [%s] seconds: [%s]" % (CONFIG['grace'], CONFIG['action'])
    msg2 = "To cancel this operation, press any key in any terminal"
    debug(logging.WARNING, msg1)
    commands.getoutput("echo '%s\n%s' | wall" % (msg1, msg2))

# Inform the user suspend has been cancelled
def alert_user_cancelled ():
    global CONFIG
    msg = "PowerNap detected activity. Canceling action [%s]" % CONFIG['action']
    debug(logging.WARNING, msg)
    commands.getoutput("echo '%s' | wall" % msg)

# TODO: notify authorities about action taken
def notify_authorities():
    global CONFIG
    debug(logging.WARNING, "Taking action [%s]" % CONFIG['action'])

# Zero the counters and take the action
def take_action():
    global CONFIG, PROCESSES
    notify_authorities()
    os.system(CONFIG['action'])

# Handler for asynchronous external signals
def take_action_handler(signal, frame):
    if ( sig == signal.SIGUSR1 ): take_action()

# ###########################################################################
# Monitors
#   monitors are the key element in this system, they monitor particular
#   aspects of the system to determine if activity is present that should
#   stop the machine from going into suspend
#
#   The implementation is not as python like as it could be, its assumed
#   that all Monitor extend from the Monitor class which provides the basic
#   "stubbed" interface
#
#   Most monitors don't run seperate threads, however some do and therefore
#   the start/stop methods are added (could also be used to reset counts
#   etc...)
# ###########################################################################

# Generic monitor (doesn't really do much)
#   Note: as this is python there it's not required that anything extend from
#         this. It's merely here for conveinience and to serve as a guide as
#         to the required API that should be provided by Monitor objects
class Monitor ( object ):
    def __init__ ( self, name ):
        self.name = name
        debug(logging.DEBUG, "Creating monitor %s" % name)
    def __repr__ ( self ):
        return self.name

    # Reset monitor
    def reset ( self ): pass

    # Start the monitor
    def start ( self ): pass

    # Stop the monitor
    def stop  ( self ): pass

    # Check if monitored resource is active
    def active ( self ): return False

# Monitor /dev/input
class InputMonitor ( Monitor, threading.Thread ):
    def __init__ ( self ):
        threading.Thread.__init__(self)
        Monitor.__init__(self, "console")
        self.event   = False

    def reset ( self ): self.event = False

    def start ( self ): threading.Thread.start(self)

    def active ( self ):
        ret = self.event
        self.event = False
        return ret

    # Monitor /dev/input
    #   Note: it is assumed that /dev/input is completely static!
    #         i.e. if someone plugs a hot-pluggable input device (such as a 
    #              USB keyboard/mouse) this will not be detected (unless
    #              present when this process starts
    #   TODO: would be better to fix this, I've done it before so not too 
    #         difficult
    def run ( self ):
        global RUNNING
        import select

        # Get all events
        poll = select.poll()
        fps  = []
        for f in os.listdir('/dev/input'):
            path = os.path.join('/dev/input', f)
            if not os.path.isdir(path):
                fp   = open(path)
                fps.append(fp)
                poll.register(fp, select.POLLIN)
                debug(logging.DEBUG, '%s - adding input device %s' % (self, path))

        # Poll for events
        while RUNNING:
            res = poll.poll(1000)
            if ( res ):
               for fd, e in res:
                   if e & select.POLLIN:
                       self.event = True
                       os.read(fd, 32768) # Read what is there!

        # Close the files
        for fp in fps: fp.close()
      
# Process monitor
#   monitors static processes (i.e. presence in /proc is enough)
class ProcessMonitor ( Monitor ):
    def __init__ ( self, regex, name = None ):
        if not name: name = "proc:%s" % regex
        Monitor.__init__(self, name)
        self.regex = re.compile(regex)
        self.pids  = []

    def reset ( self ): self.pids = []

    def active ( self ):
      self.pids = find_pids(self.regex)
      return len(self.pids) > 0

# IO monitor
#   monitor IO activity on a process (i.e. presence alone is not enough)
class IOMonitor ( ProcessMonitor ):
    def __init__ ( self, regex, name = None ):
        if not name: name = "ioproc:%s" % regex
        ProcessMonitor.__init__(self, regex, name)
        self.io_counts = {}

    def reset ( self ):
        ProcessMonitor.reset(self)
        self.io_counts = {}

    def active ( self ):
        ret = False
        
        # Get new PID list from parent
        ProcessMonitor.active(self)

        # Get IO counts for all PIDs
        io_counts = {}
        for pid in self.pids:
            io_counts[pid] = {}
            try:
                fp = open('/proc/%d/io' % pid)
                for l in fp.readlines():
                    pts = l.split(':')
                    io_counts[pid][pts[0].strip()] = int(pts[1].strip())
                fp.close()
            except: pass # its possible the proc will die in here!

        # Update counts
        for pid in self.pids:

            # New process (assume activity)
            if pid not in self.io_counts:
               ret = True
               debug(logging.DEBUG, '    %s - adding new PID %d to list' % (self, pid))

            # Existing: check for change
            else:
                tmp = False
                for f in self.io_counts[pid]:
                    if self.io_counts[pid][f] != io_counts[pid][f]: tmp = True
                if ( tmp ): debug(logging.DEBUG, '    %s - PID %d has IO activity' % (self, pid))
                ret = tmp

            # Update count
            self.io_counts[pid] = io_counts[pid]

        # Remove old
        rem = []
        for pid in self.io_counts:
            if pid not in self.pids:
                rem.append(pid)
        for pid in rem:
            debug(logging.DEBUG, '    %s - PID %d no longer exists' % (self, pid))
            self.io_counts.pop(pid)

        return ret

# Monitor UDP messages
class RemoteMonitor ( Monitor, threading.Thread ):
    def __init__ ( self, port = 9 ):
        threading.Thread.__init__(self)
        Monitor.__init__(self, "remote")
        self.data    = False
        self.port    = port

    def reset ( self ): self.data = False

    def start ( self ): threading.Thread.start(self)

    def active ( self ):
        ret = self.data
        self.data = False
        return ret

    # Open port and wait for data (any data will trigger the monitor)
    def run ( self ):
        global RUNNING
        import socket

        # Create socket
        sock   = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        listen = False

        while RUNNING:
            if not listen:
                try:
                    debug(logging.DEBUG, '%s - configure socket' % self)
                    sock.bind(('', self.port))
                    sock.settimeout(1.0)
                    listen = True
                except Exception, e:
                    debug(logging.ERROR, '%s - failed to config socket [e=%s]' % (self, str(e)))
                    time.sleep(1.0)
            else:
                try:
                    # Wait for data
                    sock.recvfrom(1024)
                    debug(logging.DEBUG, '%s - data packet received' % self)
                    self.data = True
                except: pass # timeout

# Find list of PIDs that match a given regex (cmdline)
#   Note: I prefer using the /proc filesystem to ps output, less parsing is required!
def find_pids ( regex ):
    ret = []
  
    for d in os.listdir('/proc'):
        try:
            path = '/proc/%s/cmdline' % d
            if os.path.isfile(path):
                fp      = open(path)
                cmdline = fp.read()
                fp.close()
                if regex.search(cmdline):
                    ret.append(int(d))
        except: pass

    return ret

# ###########################################################################
# Main 
# ###########################################################################

# Search process table, increment counters, take actions, sleep
def powernapd_loop():
    global RUNNING, CONFIG
    last_a = time.time()
    warned = False

    # Until told to stop
    while RUNNING:

        # Sleep (get accurate period?)
        debug(logging.DEBUG, "Sleeping [%d] seconds" % CONFIG['interval'])
        time.sleep(CONFIG['interval'])

        # Check for each monitor
        active = 0
        for m in MONITORS:
            if m.active():
                debug(logging.DEBUG, '  %-30s is active' % m)
                active += 1
            else:
                debug(logging.DEBUG, '  %-30s is inactive' % m)

        # Something is active
        if ( active > 0 ):
            debug(logging.DEBUG, "Active monitors detected [count = %d]" % active)
            last_a = time.time()

            # Inform sysem users suspend terminated
            if warned:
                alert_user_cancelled()
                warned = False
          
        # Absent
        else:
            now    = time.time()
            absent = now - last_a
            debug(logging.DEBUG, "No active monitors detected [absent = %d/%d]" % (absent, CONFIG['absent']))

            # Time is up (powerdown)
            if ( absent >= CONFIG['absent'] ):
                take_action()

                # Wakeup (reset)
                warned = False
                last_a = time.time()
                for m in MONITORS: m.reset()

                # Log sleep period
                asleep = last_a - now
                days   = int(asleep / 86400)
                asleep = asleep % 86400
                hrs    = int(asleep / 3600)
                asleep = asleep % 3600
                mins   = int(asleep / 60)
                secs   = asleep % 60
                debug(logging.INFO, "System resumed after being asleep for %02d days %02d hrs %02d min %02d sec"
                      % (days, hrs, mins, secs))

            # Grace period
            elif ( (CONFIG['absent'] - absent) <= CONFIG['grace'] ):
                if ( not warned ):
                    alert_user_warning()
                    warned = True

# Main program
if __name__ == '__main__':

    # Ensure that only one instance runs
    daemonize()
    setup_signal_handlers()
    create_pid()
  
    # Debug
    debug(logging.INFO, "Starting monitors: %s" % MONITORS)

    # Start
    try:
        for m in MONITORS: m.start()

        # Enter the main loop
        powernapd_loop()

    # Oh dear!
    except Exception, e:
        debug(logging.ERROR, "Unexpected exception [e=%s]" % e)

    # Shut it all down
    finally:
        for m in MONITORS: m.stop()
        debug(logging.INFO, "Powernap Daemon terminating")
        sys.exit(0)
